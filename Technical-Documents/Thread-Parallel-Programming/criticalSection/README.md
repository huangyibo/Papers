### 使用Pthread实现多线程共享内存编程

#### 1 概述

使用Pthread实现多线程共享内存编程时，因为不同线程之间存在**共享内存**（操作系统术语为critical section **临界区**）。因此如何保证不同的线程对共享内存的顺序访问是关键问题。解决方案有：
(1) 如果只有同一段代码的不同线程访问临界区，可以采用循环忙等待、互斥量、信号量来解决互斥访问问题
(2) 如果有不同代码的不同线程访问临界区，需要使用信号量和读写锁实现这些线程之间的**同步**访问问题，显然问题(2)解决更复杂

#### 2 代码说明
1. criticalSection1.c 代码的执行结果是错误的，使用loop.sh脚本会执行非常多的次数会发现问题
2. criticalSection1-1.c  代码要针对criticalSection1.c提出的问题，采用读写锁校正程序，使得程序能够正常运行,(2018-11-01 读写锁未能正确地解决criticalSection1.c提出的问题，**暂时搁置**)
3. criticalSection1-1-1.c  代码针对criticalSection1.c提出的问题，在add中维护一个只能自己访问的全局变量，并用信号量保护起来，当add的线程全部执行完之后，会激活sub函数的信号量，这个方法也被称为条件变量
3. criticalSection2.c 代码采用pthread_mutex_t互斥量控制不同线程对临界区的访问，代码不存在任何问题
4. criticalSection2-2.c 代码采用循环忙等待的方式解决临界区的访问出错问题，循环忙等待比互斥量存在的优势是：循环忙等待保证了线程的顺序。但是循环忙等待一直在轮训，浪费CPU资源
5. criticalSection3.c 代码采用semaphore信号量解决了临界区访问存在的问题，semaphore的使用方法和pthread_mutex_t互斥量的使用方法一样

### 3 使用的技术

* 循环忙等待 loop busy watting
* 互斥量 mutex
    * 互斥量解决同一个代码的不同线程共同访问同一个共享变量问题
* 信号量 semaphore
    * 将信号量当做互斥量，其使用方法和互斥量的步骤完全一样
    * 信号量+额外的条件变量实现不同线程之间同步访问同一个共享变量问题
    * 信号量解决生产者-消费者问题
* 读写锁 read-write lock
    * 读写锁存在多种不同的实现方法
    * 读写锁解决线程之间的同步问题

### 4 结论

使用3中提出的技术解决同一个问题，得出的结论是：**采用信号量+条件变量** 控制灵活，并且能够完全的解决出现的问题。
