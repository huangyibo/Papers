### 使用Pthread实现多线程共享内存编程

#### 1 概述

使用Pthread实现多线程共享内存编程时，因为不同线程之间存在**共享内存**（操作系统术语为critical section **临界区**）。因此如何保证不同的线程对共享内存的顺序访问是关键问题。解决方案有：
(1) 如果只有同一段代码的不同线程访问临界区，可以采用循环忙等待、互斥量、信号量来解决互斥访问问题
(2) 如果有不同代码的不同线程访问临界区，需要使用信号量和读写锁实现这些线程之间的**同步**访问问题，显然问题(2)解决更复杂

#### 2 代码说明
1. criticalSection1.c 代码的执行结果是错误的，使用loop.sh脚本会执行非常多的次数会发现问题
2. criticalSection1-1.c  代码要针对criticalSection1.c提出的问题，采用读写锁校正程序，使得程序能够正常运行
3. criticalSection1-1-1.c  代码针对criticalSection1.c日出的问题，采用生产者消费者问题的解决方法，使得不同线程之间能够进行同步
3. criticalSection2.c 代码采用pthread_mutex_t互斥量控制不同线程对临界区的访问，代码不存在任何问题
4. criticalSection2-2.c 代码采用循环忙等待的方式解决临界区的访问出错问题，循环忙等待比互斥量存在的优势是：循环忙等待保证了线程的顺序。但是循环忙等待一直在轮训，浪费CPU资源
5. criticalSection3.c 代码采用semaphore信号量解决了临界区访问存在的问题，semaphore的使用方法和pthread_mutex_t互斥量的使用方法一样

### 3 使用的技术

* 循环忙等待 loop busy watting
* 互斥量 mutex
* 信号量 semaphore
    * 将信号量当做互斥量，其使用方法和互斥量的步骤完全一样
    * 信号量还能用来解决生产者-消费者问题
* 读写锁 read-write lock
    * 读写锁存在多种不同的实现方法
